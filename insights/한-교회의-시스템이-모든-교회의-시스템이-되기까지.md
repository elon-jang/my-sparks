---
id: "20260220-082728-inst"
title: "한 교회의 시스템이 모든 교회의 시스템이 되기까지"
category: "insights"
tags: [architecture, deployment, separation-of-concerns]
created: "2026-02-20T08:27:28Z"
source: "Oikos Finance Phase A — instance/ 분리 작업"
blog_link: null
confidence: 4
connections: []
review_count: 0
last_reviewed: null
---

# 한 교회의 시스템이 모든 교회의 시스템이 되기까지

## 시작은 하나의 교회였다

Oikos는 매주 반복되는 헌금 전표 입력을 자동화하기 위해 만들어졌다. OCR로 전표를 읽고, 교인 명부와 대조하고, Excel로 출력하는 시스템. 34번의 Phase를 거치며 DB, API, 대시보드, AI 인사이트까지 갖춘 제법 완성된 재정 관리 시스템이 되었다.

그런데 문제가 하나 있었다. 이 시스템의 DNA 곳곳에 "한 교회"의 흔적이 박혀 있었다는 것.

## 코드에 스며든 개인정보

```python
# 실제 Google Drive 폴더 ID가 코드에
GDRIVE_FOLDER_ID = "1AoSihy8FvbqrQP6Jzfjuw1cnKIBSoqx4"

# 누군가의 개인 경로가 기본값으로
GDRIVE_CREDENTIALS_PATH = "~/elon/credentials/gdrive-credentials.json"

# 실제 이메일 주소가 설정 파일에
"recipients": ["mightykid@gmail.com", "shim7648@daum.net"]
```

코드를 공개하면 개인정보가 노출되고, 다른 교회가 쓰려면 코드 여기저기를 수정해야 한다. "소프트웨어가 여행을 떠나려면 짐을 따로 싸야 한다"는 걸 깨달은 순간이었다.

## 핵심 결정: instance/ 패턴

해법은 단순했다. **코드(여행자)와 데이터(짐)를 완전히 분리**하는 것.

```
finance/
├── instance/          ← 교회별 데이터 (.gitignore)
│   ├── .env           ← DB, SMTP, API 키
│   ├── church_config.json  ← 교회 이름, 앱 이름
│   ├── members.txt    ← 교인 명부
│   └── credentials/   ← Google OAuth
├── instance.example/  ← 설치 가이드 (git 포함)
└── scripts/           ← 코드 (모든 교회 공통)
```

새 교회가 설치할 때는 `cp -r instance.example instance` 한 줄이면 된다. 코드는 한 글자도 건드릴 필요 없다.

## 세 가지 예상치 못한 교훈

### 1. 환경변수 로딩의 미묘한 타이밍

`instance/.env`로 환경변수를 옮겼더니 서버가 DB 연결에 실패했다. 원인은 `main.py`에서 `load_dotenv`를 호출하지 않은 것. 개별 모듈(`email_sender.py`, `auth.py`)에서 각자 `.env`를 로드하고 있었지만, DB 모듈은 순수하게 `os.environ`만 읽고 있었다.

**교훈**: 환경변수 로딩은 앱의 진입점 한 곳에서 최초 1회. 나머지는 그 결과를 신뢰한다.

### 2. Docker에서는 파일이 없어도 된다

운영 환경의 Docker 컨테이너에는 `instance/` 디렉토리가 없다. 그런데 잘 돌아간다. Docker Compose의 `env_file`이 환경변수를 직접 주입하고, `load_dotenv`는 파일이 없으면 조용히 넘어가기 때문이다. `church_config.json`이 없으면 기본값 "Oikos"가 사용된다.

**교훈**: 설정 파일 기반 시스템은 "파일 없음 = 기본값" 전략이 필수. 파일 없다고 죽으면 안 된다.

### 3. 테스트가 하드코딩을 잡아준다

하드코딩된 기본값을 빈 문자열로 바꿨더니 테스트가 깨졌다: `assert WEEKLY_SHEET_ID == "1ft5h72JN..."`. 테스트 자체가 하드코딩을 검증하고 있었던 것. 이걸 `assert isinstance(WEEKLY_SHEET_ID, str)`로 바꾸면서 "테스트는 구현이 아니라 계약을 검증해야 한다"는 원칙을 다시 확인했다.

## 분리의 체크리스트

이 작업을 통해 정리된, 설치형 배포를 위한 분리 체크리스트:

1. **인증 정보**: API 키, OAuth 토큰, DB 비밀번호 → `.env`
2. **개인 데이터**: 교인 명부, 이메일 주소 → `instance/`
3. **조직별 설정**: 교회 이름, 앱 이름 → `church_config.json`
4. **외부 서비스 ID**: Drive 폴더 ID, Sheet ID → 환경변수
5. **경로 중앙화**: 모든 인스턴스 파일 경로 → `instance_config.py` 한 곳

## 결론

소프트웨어를 "설치 가능"하게 만드는 건 새 기능을 추가하는 것과 전혀 다른 작업이다. 기능은 "무엇을 할 수 있는가"에 집중하지만, 설치 가능성은 "누가 어디서든 쓸 수 있는가"에 집중한다. 그리고 그 핵심은 놀랍도록 단순하다 — **코드에 박힌 "나"의 흔적을 모두 빼내는 것**.

---

## Q&A

**Q1: instance_config.py에서 INSTANCE_DIR을 환경변수로 오버라이드할 수 있게 한 이유는?**

Docker, CI/CD, 테스트 등 `instance/`가 프로젝트 루트에 없는 환경을 지원하기 위해서다. 예를 들어 Docker에서는 볼륨 마운트 경로가 다를 수 있고, 테스트에서는 임시 디렉토리를 쓸 수 있다.

**Q2: 왜 멀티테넌시 대신 설치형(단일 인스턴스)을 선택했는가?**

교회 재정 데이터의 민감성 때문이다. 각 교회가 자체 서버에서 독립 운영하면 데이터 격리가 완벽하고, 한 교회의 장애가 다른 교회에 영향을 주지 않는다. 교회 수가 수만 개가 아닌 이상 멀티테넌시의 운영 효율보다 데이터 독립성이 더 중요하다.

**Q3: `load_dotenv`가 파일 없으면 에러를 내지 않는다는 걸 어떻게 알았는가?**

운영 Docker 배포에서 발견했다. 컨테이너에 `instance/.env`가 없는데도 서버가 정상 동작했다. Docker Compose의 `env_file`이 환경변수를 직접 주입하므로, `load_dotenv`는 "있으면 읽고, 없으면 넘어가는" 보조 수단이 된 것이다.
